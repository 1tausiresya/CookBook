# 处理状态的变化

例如： 主节点创建了一个临时性节点来标记主节点锁，而备份主节点注册一个监视点来监视这个主节点锁是否存在，如果主节点崩溃，主节点锁自动被删除，并通知所有的备份主节点。
一旦备份主节点收到了通知，它们就开始选举，尝试通过争夺创建临时的znode节点来标记主节点锁。

这样一来，监视(watch)和通知形成了一个机制，使得客户端可以观察变化情况，不需要去轮询整个ZooKeeper集合的状态。

## 单次触发器

***事件(event)*** : 表示一个 znode 节点执行了更新操作。
***监视点(watche)*** : 表示一个与之关联的 znode 节点和事件类型组成的单次触发器（例如，znode 被赋值或者 znode 被删除）。

当一个监视点被一个事件触发时，就会产生一个通知(notification)。通知是注册了监视点的应用客户端收到的事件的报告的消息。

如果应用程序注册了一个监视点来接收通知，匹配该监视点条件的第一个事件会触发监视点的通知，并且最多触发一次。
例如： 当 znode 节点 /master 被删除时，客户端需要知道该变化，客户端在 /master 执行 ```exists``` 操作并设置监视点标志位，等待通知，客户端会以回调函数的形式收到通知。

>***注意：***
>
>客户端设置的监视点与会话关联，如果会话过期，则等待中的监视点也将被删除。
>
>不过，监视点可以跨越不同服务端的连接而保持。例如：一个 Zk 客户端与一个 Zk 服务端断开连接后，会话转移到集群中的另一个 Zk 服务端时，客户端会发送未触发的监视点列表，在注册监视点时，服务端将检查已经监视的znode节点在之前注册监视点之后是否发生了变化，如果znode节点已经发生了变化，一个监视点的事件就会被发送给客户端，否则在新的服务端注册监视点。

## 如何设置监视点watch

ZooKeeper 中的 API 的所有操作： ```getData```、```getChildren``` 和 ```exists```，均可以选择在读取的 znode 节点上设置监视点。
使用监视机制时，需要实现 Watcher 接口：

```java
public void process(WatchedEvent event);
```

```WatchedEvent``` 数据结构包括以下信息：

```java
    final private KeeperState keeperState;
    final private EventType eventType;
    private String path;
```

- **org.apache.zookeeper.Watcher.Event.KeeperState** : ZooKeeper 会话状态， 值包含：
    - Disconnected (0) : 客户端与Zk服务端失去连接
    - SyncConnected (3) ： 客户端与Zk服务端处于连接有效状态
    - AuthFailed (4) ： 身份验证失败的状态
    - ConnectedReadOnly (5) ： 客户端处于只读连接的状态；客户端连接到一个只读的服务器（即该服务器目前没有连接到大都数）
    - SaslAuthenticated(6) : SASL 验证通过状态；由于客户端是通过SASL授权验证连接到服务端的，所以可以通过sasl授权的权限执行Zookeeper操作。
    - Expired (-112) ： 会话失效
    
- **org.apache.zookeeper.Watcher.Event.EventType** : 事件类型，值包括：
    - None (-1)  : 无
    - NodeCreated (1) ： 节点创建
    - NodeDeleted (2) ： 节点删除
    - NodeDataChanged (3) ： 节点数据变更
    - NodeChildrenChanged (4) ：子节点变更

- 如果事件类型不是 None 时， 则还会返回一个 znode 路径

>监视点有2种类型： 数据监视点、子节点监视点。
>
>创建、删除 或者 设置一个 znode 节点的数据都会触发数据监视点， ```exists``` 、 ```getData``` 这2个操作可以设置数据监视点。
>
>只有 ```getChildren``` 操作可以设置子节点监视点，这种监视点只有在 znode 子节点创建或删除时才被触发。

对于这些事件，可以通过以下调用设置监视点：

- NodeCreated

  通过 exists 调用设置一个监视点

- NodeDeleted

  通过 exists、getData 设置监视点
  
- NodeDataChanged

  通过 exists、getData 设置监视点
  
- NodeChildrenChanged

  通过 getChildren 设置监视点 
  
  
当创建一个 ZooKeeper 对象时（前面几节的内容我们可以看到），需要传递一个默认的Watcher对象，Zk 会使用这个监视点来通知应用Zk状态的变更情况。
而对于Zk节点的事件的通知，你可以使用默认的监视点，也可以单独实现一个。

```java
public byte[] getData(final String path, Watcher watcher, Stat stat) // 传入自定义的监视点watcher
public byte[] getData(String path, boolean watch, Stat stat)  // 该方法watch参数传true，则表示使用默认的监视点
``` 

```stat``` 入参为Stat 类型的实例化参数， Zk 使用该对象返回指定的 path 参数的 znode 节点信息。
Stat 结构包括 znode 节点的属性信息，如该 znode 节点的属性信息， 如该 znode 节点的上次更新(zxid) 的时间戳，以及该znode节点的子节点数。

Stat 的结构字段信息如下：https://zookeeper.apache.org/doc/r3.4.13/zookeeperProgrammers.html
```zxid``` 表示事务id。
```java
  private long czxid; // 导致这个 znode 创建的变更的 zxid
  private long mzxid; // 上次变更这个 znode 的变更的 zxid
  private long ctime; // 创建这个 znode 的时间，截至目前的毫秒数
  private long mtime; // 这个 znode 上次变更至今的毫秒数
  private int version; // 这个 znode 的变更的次数
  private int cversion; // 这个 znode 的子节点的变更次数
  private int aversion; // 这个 znode 的 ACL 变更的次数
  private long ephemeralOwner; // 这个 znode 不是临时节点则为0； 这个 znode 是临时节点则表示持有该节点的会话id
  private int dataLength; // 这个 znode 的数据长度
  private int numChildren; // 这个 znode 的子节点数
  private long pzxid; // 上次变更这个 znode 的子节点的变更的 znode
```

> **注意事项：**
>
>在 Zk 的会话状态和 znode 节点的变化事件中，使用了相同的监视机制来处理应用程序的相关事件的通知。虽然会话状态、znode状态变更 是两个独立的事件集合，为了简便，使用相同的机制传送这些事件。

## 普遍模型

通过前面的案例，我们总结出在 ZooKeeper 的应用中使用的通用代码的模型：

- 1. 进行异步方法调用
- 2. 实现回调对象， 并传入异步调用函数中
- 3. 如果操作需要设置监视点，实现一个 Watcher 对象， 并传入异步调用函数中

这是一个简单是示例(仅作展示用)：

```java
zk.exists("/myZnode", myWatcher, existsCallback, null);

Watcher myWatcher = new Watcher(){
    public void process(WatchedEvent e){
        // ...
    }
}

StatCallback existsCallback = new StateCallback(){
    public void processResult(int rc, String path, Object ctx, Stat stat){
        // ...
    }
};
```

## 主从模式案例

现在具体通过主-从模式的例子来查看如何处理状态的变化。假设任务处理过程中遇到：

- 管理权变化
- 主节点等待从节点列表的变化
- 主节点等待新任务进行分配
- 从节点等待分配新任务
- 客户端等待任务的执行结果



