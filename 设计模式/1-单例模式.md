## 单例模式

### 什么是单例模式

单例模式属于管理实例的创造型类型模式。单例模式保证在你的应用种最多只有一个指定类的实例。

### 单例模式应用场景

- 项目配置类
>读取项目的配置信息的类可以做成单例的，因为只需要读取一次，且配置信息字段一般比较多节省资源。通过这个单例的类，可以对应用程序中的类进行全局访问。无需多次对配置文件进行多次读取。

- 应用日志类
>日志器Logger在你的应用中是无处不在的。也应该只初始化一次，但是可以到处使用。

- 分析和报告类
>如果你在使用一些数据分析工具例如Google Analytics。你就可以注意到它们被设计成单例的，仅仅初始化一次，然后在用户的每一个行为中都可以使用。

![单例模式简图](Singleton-Class-Diagram-.png)


### 实现单例模式的类

- 将默认的构造器设置为private。阻止其他类从应用中直接初始化该类。

- 创建一个public static 的静态方法。该方法用于返回一个单例类实例。

- 还可以选择懒加载初始化更友好。

### 示例代码

示例代码参见以下类

- org.byron4j.cookbook.designpattern.singleton.Singleton

```
public class Singleton {

    private static Singleton instance;

    // 构造器私有化
    private Singleton(){

    }

    // 提供静态方法
    public static Singleton getInstance(){

        // 懒加载初始化，在第一次使用时才创建实例
        if(instance == null){
            instance = new Singleton();
        }
        return  instance;
    }


    public void display(){
        System.out.println("Hurray! I am create as a Singleton!");
    }


}
```



### 线程安全的单例模式

线程安全对于单例类来说是非常重要的。上述Singleton类是非线程安全的，因为在线程并发的场景下，可能会创建多个Singleton实例。

为了规避这个问题，我们可以将 getInstance 方法用同步字 synchronized 修饰，这样迫使线程等待直到前面一个线程执行完毕，如此就避免了同时存在多个线程访问该方法的场景。

```java
public static synchronized Singleton getInstance() {
		
		// Lazy initialization, creating object on first use
		if (instance == null) {
			instance = new Singleton();
		}
		return instance;
}
```

这样确实解决了线程安全的问题。但是，```synchronized``` 关键字存在严重的性能问题。我们还可以进一步优化 getInstance 方法，将实例同步，将方法范围缩小：

```
public static Singleton getInstance() {

		// Lazy initialization, creating object on first use
		if (instance == null) {
			synchronized (Singleton.class) {
				if (instance == null) {
					instance = new Singleton();
				}
			}
		}

	return instance;

}
```

